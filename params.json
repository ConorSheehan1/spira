{"name":"Spira","tagline":"Spira is a framework for viewing RDF data as model objects","body":"# Spira [![Build Status](https://travis-ci.org/ruby-rdf/spira.png?branch=master)](http://travis-ci.org/ruby-rdf/spira)\r\n\r\nIt's time to breathe life into your linked data.\r\n\r\n## Need Help? Use our Google Group\r\n\r\nIf you have any question on how to use Spira, please use the [Google Group ruby-rdf](https://groups.google.com/forum/#!forum/ruby-rdf).\r\n\r\n## Synopsis\r\nSpira is a framework for using the information in [RDF.rb][] repositories as model\r\nobjects.  It gives you the ability to work in a resource-oriented way without\r\nlosing access to statement-oriented nature of linked data, if you so choose.\r\nIt can be used either to access existing RDF data in a resource-oriented way,\r\nor to create a new store of RDF data based on simple defaults.\r\n\r\nAn introductory blog post is at <http://blog.datagraph.org/2010/05/spira>\r\n\r\nA changelog is available in the {file:CHANGES.md} file.\r\n\r\n### Example\r\n\r\n```ruby\r\nclass Person < Spira::Base\r\n\r\n  configure :base_uri => \"http://example.org/example/people\"\r\n\r\n  property :name, :predicate => FOAF.name, :type => String\r\n  property :age,  :predicate => FOAF.age,  :type => Integer\r\n\r\nend\r\n\r\nbob = RDF::URI(\"http://example.org/people/bob\").as(Person)\r\nbob.age  = 15\r\nbob.name = \"Bob Smith\"\r\nbob.save!\r\n\r\nbob.each_statement {|s| puts s}\r\n#=> RDF::Statement:0x80abb80c(<http://example.org/example/people/bob> <http://xmlns.com/foaf/0.1/name> \"Bob Smith\" .)\r\n#=> RDF::Statement:0x80abb8fc(<http://example.org/example/people/bob> <http://xmlns.com/foaf/0.1/age> \"15\"^^<http://www.w3.org/2001/XMLSchema#integer> .)\r\n```\r\n\r\n### Features\r\n\r\n * Extensible validations system\r\n * Extensible types system\r\n * Easy to adapt models to existing data\r\n * Open-world semantics\r\n * Objects are still RDF.rb-compatible enumerable objects\r\n * No need to put everything about an object into Spira\r\n * Easy to use a resource as multiple models\r\n\r\n## ActiveModel integration\r\n\r\nThis is a version of Spira that makes use of ActiveModel. The goal of this version is\r\nto replace all the internals of Spira with ActiveModel hooks, and thus get rid of\r\nsuperfluous code and increase compatibility with Rails stack. I want it to be\r\na drop-in replacement for ActiveRecord or any other mature ORM solution they use\r\nwith Ruby on Rails.\r\n\r\nAlthough I've been trying to make the impact of this transition to be as little\r\nas possible, there are a few changes that you should be aware of:\r\n\r\n * Read the comments on \"new_record?\" and \"reload\" methods. They are key methods in\r\n   understanding how Spira is working with the repository. Basically, a Spira record\r\n   is new, if the repository has no statements with this record as subject. This means,\r\n   that *the repository is queried every time you invoke \"new_record?\"*.\r\n   Also note that if Spira.repository is not set, your Spira resource will always be \"new\".\r\n   Also note that instantiating a new Spira resource sends a query to the repository,\r\n   if it is set, but should work just fine even if it's not (until you try to \"save\" it).\r\n * Customary Rails' record manipulation methods are preferred now.\r\n   This means, you should use more habitual \"save\", \"destroy\", \"update_attributes\", etc.\r\n   instead of the \"save!\", \"destroy!\", \"update\", \"update!\" and others, as introduced\r\n   by the original Spira gem.\r\n * Callbacks are now handled by ActiveModel. Previous ways of defining them are\r\n   no longer valid. This also introduces the \"before_\", \"after_\" and \"around_\" callbacks\r\n   as well as their \"_validation\", \"_save\", \"_update\" and \"_create\" companions for you to enjoy.\r\n * Validations are also handled by ActiveModel. With all the helper methods you have in\r\n   ActiveRecord.\r\n * A spira resource (class) must be defined by *inheriting* it from Spira::Base.\r\n   Using \"include Spira::Resource\" is *temporarily* broken, but will be back at some point,\r\n   with improvements and stuff.\r\n * \"after/before_create\" callbacks are *not* called when only the properties of your\r\n   Spira resource are getting persisted. That is, you may create a \"type\"-less Spira resource,\r\n   assign properties to it, then #save it -- \"_create\" callbacks will not be triggered,\r\n   because Spira cannot infer a resource definition (\"resource - RDF.type - type\")\r\n   for such resource and will only persist its properties.\r\n   Although this is how the original Spira behaves too, I thought I'd state it\r\n   explicitly here before you start freaking out.\r\n * Configuration options \"base_uri\", \"default_vocabulary\" are\r\n   now configured via \"configure\" method (see the examples below).\r\n * A couple of (not so) subtle changes:\r\n   1) Global caching is gone. This means that \"artist.works.first.artist\" (reverse lookup)\r\n   does not return the original artist, but its copy retrieved from the database.\r\n\r\n## Getting Started\r\n\r\nThe easiest way to work with Spira is to install it via Rubygems:\r\n\r\n    $ sudo gem install spira\r\n\r\nDownloads will be available on the github project page, as well as on Rubyforge.\r\n\r\n## Defining Model Classes\r\n\r\nTo use Spira, define model classes for your RDF data.  Spira classes include\r\nRDF, and thus have access to all `RDF::Vocabulary` classes and `RDF::URI`\r\nwithout the `RDF::` prefix.  For example:\r\n\r\n```ruby\r\nrequire 'spira'\r\n    \r\nclass CD < Spira::Base\r\n  configure :base_uri => 'http://example.org/cds'\r\n  property :name,   :predicate => DC.title,   :type => XSD.string\r\n  property :artist, :predicate => URI.new('http://example.org/vocab/artist'), :type => :artist\r\nend\r\n\r\nclass Artist < Spira::Base\r\n  configure :base_uri => 'http://example.org/artists'\r\n  property :name, :predicate => DC.title, :type => XSD.string\r\n  has_many :cds,  :predicate => URI.new('http://example.org/vocab/published_cd'), :type => XSD.string\r\nend\r\n```\r\n\r\nThen use your model classes, in a way more or less similar to any number of ORMs:\r\n\r\n```ruby\r\ncd = CD.for(\"queens-greatest-hits\")\r\ncd.name = \"Queen's greatest hits\"\r\nartist = Artist.for(\"queen\")\r\nartist.name = \"Queen\"\r\n\r\ncd.artist = artist\r\ncd.save!\r\nartist.cds = [cd]\r\nartist.save!\r\n\r\nqueen = Artist.for('queen')\r\nhits = CD.for 'queens-greatest-hits'\r\nhits.artist == artist == queen\r\n```\r\n\r\n### URIs and Blank Nodes\r\n\r\nSpira instances have a subject, which is either a URI or a blank node.\r\n\r\nA class with a base URI can instantiate with a string (or anything, via to_s),\r\nand it will have a URI representation:\r\n\r\n```ruby\r\nArtist.for('queen')\r\n```\r\n\r\nHowever, a class is not required to have a base URI, and even if it does, it\r\ncan always access classes with a full URI:\r\n\r\n```ruby\r\nnk = Artist.for(RDF::URI.new('http://example.org/my-hidden-cds/new-kids'))\r\n```\r\n\r\nIf you have a URI that you would like to look at as a Spira resource, you can instantiate it from the URI:\r\n\r\n```ruby\r\nRDF::URI.new('http://example.org/my-hidden-cds/new-kids').as(Artist)\r\n# => <Artist @subject=http://example.org/my-hidden-cds/new-kids>\r\n```\r\n\r\nAny call to 'for' with a valid identifier will always return an object with nil\r\nfields.  It's a way of looking at a given resource, not a closed-world mapping\r\nto one.\r\n\r\nYou can also use blank nodes more or less as you would a URI:\r\n\r\n```ruby\r\nremix_artist = Artist.for(RDF::Node.new)\r\n# => <Artist @subject=#<RDF::Node:0xd1d314(_:g13751060)>>\r\nRDF::Node.new.as(Artist)\r\n# => <Artist @subject=#<RDF::Node:0xd1d314(_:g13751040)>>\r\n```\r\n\r\nFinally, you can create an instance of a Spira projection with #new, and you'll\r\nget an instance with a shiny new blank node subject:\r\n\r\n```ruby\r\nformerly_known_as_prince = Artist.new\r\n# => <Artist @subject=#<RDF::Node:0xd1d314(_:g13747140)>>\r\n```\r\n\r\n### Class Options\r\n\r\nA number of options are available for Spira classes.\r\n\r\n#### base_uri\r\n\r\nA class with a `base_uri` set (either an `RDF::URI` or a `String`) will\r\nuse that URI as a base URI for non-absolute `for` calls.\r\n\r\nExample\r\n```ruby\r\nCD.for 'queens-greatest-hits' # is the same as...\r\nCD.for RDF::URI.new('http://example.org/cds/queens-greatest-hits')\r\n```\r\n\r\n#### type\r\n\r\nA class with a `type` set is assigned an `RDF.type` on creation and saving.\r\n\r\n```ruby\r\nclass Album < Spira::Base\r\n  type URI.new('http://example.org/types/album')\r\n  property :name,   :predicate => DC.title\r\nend\r\n\r\nrolling_stones = Album.for RDF::URI.new('http://example.org/cds/rolling-stones-hits')\r\n# See RDF.rb at http://rdf.rubyforge.org/RDF/Enumerable.html for more information about #has_predicate?\r\nrolling_stones.has_predicate?(RDF.type) #=> true\r\nAlbum.type #=> RDF::URI('http://example.org/types/album')\r\n`\r\n\r\nIn addition, one can count the members of a class with a `type` defined:\r\n\r\n```ruby\r\nAlbum.count  #=> 1 \r\n```\r\n\r\n\r\nIt is possible to assign multiple types to a Spira class:\r\n\r\n```ruby\r\nclass Man < Spira::Base\r\n  type RDF::URI.new('http://example.org/people/father')\r\n  type RDF::URI.new('http://example.org/people/cop')\r\nend\r\n```\r\n\r\nAll assigned types are accessible via \"types\":\r\n\r\n```ruby\r\nMan.types #=> #<Set: {#<RDF::URI:0xd5ebc0(http://example.org/people/father)>, #<RDF::URI:0xd5e4b8(http://example.org/people/cop)>}>\r\n```\r\n\r\nAlso note that \"type\" actually returns a first type from the list of types.\r\n\r\n\r\n#### property\r\n\r\nA class declares property members with the `property` function.  See `Property Options` for more information.\r\n\r\n#### has_many\r\n\r\nA class declares list members with the `has_many` function.  See `Property Options` for more information.\r\n\r\n#### default_vocabulary\r\n\r\nA class with a `default_vocabulary` set will transparently create predicates for defined properties:\r\n\r\n```ruby\r\nclass Song < Spira::Base\r\n  configure :default_vocabulary => URI.new('http://example.org/vocab'),\r\n            :base_uri => 'http://example.org/songs'\r\n  property :title\r\n  property :author, :type => :artist\r\nend\r\n\r\ndancing_queen = Song.for 'dancing-queen'\r\ndancing_queen.title = \"Dancing Queen\"\r\ndancing_queen.artist = abba\r\n# See RDF::Enumerable for #has_predicate?\r\ndancing_queen.has_predicate?(RDF::URI.new('http://example.org/vocab/title'))  #=> true\r\ndancing_queen.has_predicate?(RDF::URI.new('http://example.org/vocab/artist')) #=> true\r\n```\r\n\r\n### Property Options\r\n\r\nSpira classes can have properties that are either singular or a list.  For a\r\nlist, define the property with `has_many`, for a property with a single item,\r\nuse `property`.  The semantics are otherwise the same.  A `has_many` property\r\nwill always return a list, including an empty list for no value.  All options\r\nfor `property` work for `has_many`.\r\n\r\n    property :artist, :type => :artist    #=> cd.artist returns a single value\r\n    has_many :cds,    :type => :cd        #=> artist.cds returns an array\r\n\r\nProperty always takes a symbol name as a name, and a variable list of options.  The supported options are:\r\n\r\n * `:type`: The type for this property.  This can be a Ruby base class, an \r\n   RDF::XSD entry, or another Spira model class, referenced as a symbol.  See\r\n   **Types** below.  Default: `Any`\r\n * `:predicate`: The predicate to use for this type.  This can be any RDF URI.\r\n   This option is required unless the `default_vocabulary` has been used.\r\n * `:localized`: Indicates if the property is multilingual. See 'Localized Properties'\r\n\r\n#### Localized Properties\r\n\r\nA localized property allows to define a value per language. It only works with\r\nproperties having a single item, ie defined with `property`.\r\n\r\n```ruby\r\nclass Article < Spira::Base\r\n  property :label, :localized => true\r\nend\r\n\r\n# default locale :en\r\nrandom_article = Article.for 'random-article'\r\nrandom_article.label = \"A label in english\"\r\ni18n.locale = :fr\r\nrandom_article.label = \"Un libellé en français\"\r\n\r\nrandom_article.label_native\r\n# #=> [#<RDF::Literal:0xdb47c8(\"A label in english\"@en)>, #<RDF::Literal:0xe5c3d8(\"Un libellé en français\"@fr)>]\r\n\r\nrandom_article.label_with_locales\r\n# #=> {:en=>\"A label in english\", :fr=>\"Un libellé en français\"}\r\n```\r\n\r\n### Types\r\n\r\nA property's type can be either a class which includes Spira::Type or a\r\nreference to another Spira model class, given as a symbol.\r\n\r\n#### Relations\r\n\r\nIf the `:type` of a spira class is the name of another Spira class as a symbol,\r\nsuch as `:artist` for `Artist`, Spira will attempt to load the referenced\r\nobject when the appropriate property is accessed.\r\n\r\nIn the RDF store, this will be represented by the URI of the referenced object.\r\n\r\n#### Type Classes\r\n\r\nA type class includes Spira::Type, and can implement serialization and\r\ndeserialization functions, and register aliases to themselves if their datatype\r\nis usually expressed as a URI.  Here is the built-in Spira Integer class:\r\n\r\n```ruby\r\nmodule Spira::Types\r\n  class Integer\r\n\r\n    include Spira::Type\r\n\r\n    def self.unserialize(value)\r\n      value.object\r\n    end\r\n\r\n    def self.serialize(value)\r\n      RDF::Literal.new(value)\r\n    end\r\n\r\n    register_alias RDF::XSD.integer\r\n  end\r\nend\r\n```\r\n\r\nClasses can now use this particular type like so:\r\n\r\n```ruby\r\nclass Test < Spira::Base\r\n  property :test1, :type => Integer\r\n  property :test2, :type => RDF::XSD.integer\r\nend\r\n```\r\n\r\nSpira classes include the Spira::Types namespace, where several default types\r\nare implemented:\r\n\r\n  * `Integer`\r\n  * `Float`\r\n  * `Boolean`\r\n  * `String`\r\n  * `Any`\r\n\r\nThe default type for a Spira property is `Spira::Types::Any`, which uses\r\n`RDF::Literal`'s automatic boxing/unboxing of XSD types as best it can.  See\r\n`[RDF::Literal](http://rdf.rubyforge.org/RDF/Literal.html)` for more information.\r\n\r\nYou can implement your own types as well.  Your class' serialize method should\r\nturn an RDF::Value into a ruby object, and vice versa.\r\n\r\n```ruby\r\nmodule MyModule\r\n  class MyType\r\n    include Spira::Type\r\n    def self.serialize(value)\r\n      ...\r\n    end\r\n\r\n    def self.unserialize(value)\r\n      ...\r\n    end\r\n  end\r\nend\r\n\r\nclass MyClass < Spira::Base\r\n  property :property1, :type => MyModule::MyType\r\nend\r\n```\r\n\r\n## Defining Repositories\r\n\r\nYou can work on any kind of RDF::Repository with Spira:\r\n\r\n```ruby\r\nrequire 'rdf/ntriples'\r\nrequire 'rdf/sesame'\r\n\r\nclass Album < Spira::Base\r\nend\r\n\r\nSpira.repository = RDF::Sesame::Repository.new 'some_server'\r\n...\r\n\r\nSpira.repository = RDF::Repository.load('some_file.nt')\r\n...\r\n\r\nSpira.using_repository(RDF::Repository.load('some_file.nt')) do\r\n   ...\r\nend\r\n```\r\n\r\nSpira.repository is thread-safe, which means that each thread stores its own instance.\r\nIt allows you to work on multiple repositories at the same time:\r\n\r\n```ruby\r\nthreads = []\r\nrepositories = [RDF::Repository.new, RDF::Repository.new, RDF::Repository.new]\r\n\r\nrepositories.each do |repository|\r\n  threads << Thread.new(repository) do |repository|\r\n    Spira.repository = repository\r\n\r\n    album = Album.for(\"http://theperson.com/album/random_name\")\r\n    album.year = 1950 + (rand*100).to_i\r\n    album.save!\r\n  end\r\nend\r\n\r\nthreads.map(&:join)\r\nrepositories.map(&:size).join(', ') # 1, 1, 1\r\n```\r\n\r\n## Validations\r\n\r\n[removed]\r\nSee the description of ActiveModel::Validations.\r\n\r\n## Hooks\r\n\r\n[removed]\r\nSee the description of ActiveModel::Callbacks.\r\n\r\n## Using Model Objects as RDF.rb Objects\r\n\r\nAll model objects are fully-functional as `RDF::Enumerable`, `RDF::Queryable`,\r\nand `RDF::Mutable`.  This lets you manipulate objects on the RDF statement\r\nlevel.  You can also access attributes that are not defined as properties.\r\n\r\n## Support\r\n\r\nThere are a number of ways to ask for help.  In declining order of preference:\r\n\r\n * Fork the project and write a failing test, or a pending test for a feature request\r\n * Ask on the [public-rdf-ruby w3c mailing list][]\r\n * You can post issues to the Github issue queue\r\n * (there might one day be a google group or other such support channel, but not yet)\r\n\r\n## 'License'\r\nSpira is free and unemcumbered software released into the public\r\ndomain.  For more information, see the included UNLICENSE file.\r\n\r\n## Contributing\r\nThis repository uses [Git Flow](https://github.com/nvie/gitflow) to mange development and release activity. All submissions _must_ be on a feature branch based on the _develop_ branch to ease staging and integration.\r\n\r\n* Do your best to adhere to the existing coding conventions and idioms.\r\n* Don't use hard tabs, and don't leave trailing whitespace on any line.\r\n* Do document every method you add using [YARD][] annotations. Read the\r\n  [tutorial][YARD-GS] or just look at the existing code for examples.\r\n* Don't touch the `.gemspec`, `VERSION` or `AUTHORS` files. If you need to\r\n  change them, do so on your private branch only.\r\n* Do feel free to add yourself to the `CREDITS` file and the corresponding\r\n  list in the the `README`. Alphabetical order applies.\r\n* Do note that in order for us to merge any non-trivial changes (as a rule\r\n  of thumb, additions larger than about 15 lines of code), we need an\r\n  explicit [public domain dedication][PDD] on record from you.\r\n\r\n[public-rdf-ruby w3c mailing list]:         http://lists.w3.org/Archives/Public/public-rdf-ruby/\r\n[RDF.rb]:          http://rubygems.org/gems/rdf\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}